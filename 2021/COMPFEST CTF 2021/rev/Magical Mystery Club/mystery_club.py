

from z3 import *

s = Solver()

def ff(a1, a2, a3):
    return ee(a1, a2 + 429, a3)


def ee(a1, a2, a3):
    return dd(a1, 198 * a2, a3)


def dd(a1, a2, a3):
    return cc(a1, a2 - 81180, a3)


def cc(a1, a2, a3):
    return bbb(a1, (a2 / 198), a3)


def bbb(a1, a2, a3):
    return aa(a1, a2 - a3)


def aa(a1, a2):
    return ((a1 + a2) % 256)


def mm(a1, a2, a3):
    return ll(a1, (a2 * a2), a3)


def ll(a1, a2, a3):
    return kk(a1, (78 * a2), a3)


def kk(a1, a2, a3):
    return jj(a1, (a2 - 1595), a3)


def jj(a1, a2, a3):
    return ii(a1, -2087 * a3 + a2, a3)


def ii(a1, a2, a3):
    return hh(a1, a2 / (39 * a3 + 29), a3)


def hh(a1, a2, a3):
    return gg(a1, a2 - 2 * a3)


def gg(a1, a2):
    return ((a1 + a2) % 256)


state = 0x42

lll = [0x5d, 0xed, 0x7b, 0xdc, 0xf2, 0x37, 0xdd, 0xf8, 0x0f, 0x09, 0xd5, 0xfe, 0xad, 0x46, 0x83, 0xda, 0xf9, 0x68, 0x1e, 0xb7, 0x63, 0x68, 0x49, 0x7f, 0x8c, 0x48, 0x80, 0x87, 0xeb, 0xfb, 0x01, 0x9b, 0x7d, 0xd1, 0x6f, 0xc0, 0xd9, 0xe8, 0xde, 0xdb, 0x3d, 0x11, 0x13, 0xf9, 0x99, 0xae, 0xb8, 0x0a, 0x09, 0x58, 0xf7, 0x4d, 0xac, 0xb4, 0x78, 0x97, 0x82, 0xb4, 0xbc, 0x8d, 0x0a, 0x2d, 0x09, 0x9c, 0x8a, 0xf7, 0x69, 0xd5, 0xe8, 0xe7, 0xc4, 0xc8, 0x39, 0xce, 0x18, 0xf8, 0xaf, 0x59, 0xbd, 0x2d, 0xcc, 0x8e, 0xf7, 0xb5, 0x6c, 0x83, 0x49, 0x53, 0x80, 0xb6, 0x92, 0xb6, 0x1f, 0xda, 0x3f, 0x94, 0x43, 0x1f ]

bb = [BitVec(f'bb{i}', 64) for i in range(98)]

def fun(a):
    global state
    v4 = BitVec('v4', 64) % 255
    v1 = ff(a, v4, v4)
    v3 = v1 ^ mm(state, v4, v4)
    state *= 3
    return v3


for i in range(98):
    s.add(bb[i] > 0x20, bb[i] < 0x7f)
    s.add(lll[i] == fun(bb[i]))

s.check()
m = s.model()

w = ''

for i in range(98):
    w += chr(m[bb[i]].as_long())

print(w)

# COMPFEST13{n3Ver_Tru5t_M4tHemAg1cKal_tR1cK5s_n0BoDY_tH0u6hT_No_0ne_W0ulD_n0t1c3_4nYw4Y_98f66ab185}
