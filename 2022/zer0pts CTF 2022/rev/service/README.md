
```py
# https://github.com/crappycrypto/wincrypto/blob/master/wincrypto/native.py

from ctypes import FormatError, GetLastError
from ctypes import windll, c_void_p, byref, create_string_buffer, c_int
import struct

from wincrypto.constants import HP_ALGID, HP_HASHSIZE, KP_KEYLEN, KP_ALGID, CRYPT_EXPORTABLE

PROV_RSA_FULL = 1
PROV_RSA_AES = 24

CRYPT_NEWKEYSET = 8
NTE_BAD_KEYSET = 0x80090016


def assert_success(success):
    if not success:
        raise AssertionError(FormatError())


def CryptAcquireContext():
    hprov = c_void_p()
    success = windll.advapi32.CryptAcquireContextA(byref(hprov), 0, 0, PROV_RSA_AES, 0)
    if not success and GetLastError() & 0xffffffff == NTE_BAD_KEYSET:
        success = windll.advapi32.CryptAcquireContextA(byref(hprov), 0, 0, PROV_RSA_AES, CRYPT_NEWKEYSET)
    assert_success(success)
    return hprov


# def CryptReleaseContext(hprov):
#     success = windll.advapi32.CryptReleaseContext(hprov, 0)
#     assert_success(success)


# def CryptImportKey(hprov, keyblob, hPubKey=0):
#     hkey = c_void_p()
#     success = windll.advapi32.CryptImportKey(hprov, keyblob, len(keyblob), hPubKey, 0, byref(hkey))
#     assert_success(success)
#     return hkey


# def CryptExportKey(hkey, hexpkey, blobType):
#     # determine output buffer length
#     bdatalen = c_int(0)
#     success = windll.advapi32.CryptExportKey(hkey, hexpkey, blobType, 0, 0, byref(bdatalen))
#     assert_success(success)

#     # export key
#     bdata = create_string_buffer(b'', bdatalen.value)
#     success = windll.advapi32.CryptExportKey(hkey, hexpkey, blobType, 0, bdata, byref(bdatalen))
#     assert_success(success)
#     return bdata.raw[:bdatalen.value]


# def CryptDestroyKey(hkey):
#     success = windll.advapi32.CryptDestroyKey(hkey)
#     assert_success(success)


# def CryptDecrypt(hkey, encrypted_data):
#     bdata = create_string_buffer(encrypted_data)
#     bdatalen = c_int(len(encrypted_data))
#     success = windll.advapi32.CryptDecrypt(hkey, 0, 1, 0, bdata, byref(bdatalen))
#     assert_success(success)
#     return bdata.raw[:bdatalen.value]


# def CryptEncrypt(hkey, plain_data):
#     # determine output buffer length
#     bdatalen_test = c_int(len(plain_data))
#     success = windll.advapi32.CryptEncrypt(hkey, 0, 1, 0, 0, byref(bdatalen_test), len(plain_data))
#     assert_success(success)
#     out_buf_len = bdatalen_test.value

#     # encrypt data
#     bdata = create_string_buffer(plain_data, out_buf_len)
#     bdatalen = c_int(len(plain_data))
#     success = windll.advapi32.CryptEncrypt(hkey, 0, 1, 0, bdata, byref(bdatalen), out_buf_len)
#     assert_success(success)
#     return bdata.raw[:bdatalen.value]


# def CryptGetKeyParam(hkey, dwparam):
#     # determine output buffer length
#     bdatalen = c_int(0)
#     success = windll.advapi32.CryptGetKeyParam(hkey, dwparam, 0, byref(bdatalen), 0)
#     assert_success(success)

#     # get hash param
#     bdata = create_string_buffer(b'', bdatalen.value)
#     success = windll.advapi32.CryptGetKeyParam(hkey, dwparam, bdata, byref(bdatalen), 0)
#     assert_success(success)
#     result = bdata.raw[:bdatalen.value]
#     if dwparam in [KP_KEYLEN, KP_ALGID]:
#         result = struct.unpack('I', result)[0]
#     return result


def CryptCreateHash(hProv, Algid):
    hCryptHash = c_void_p()
    success = windll.advapi32.CryptCreateHash(hProv, Algid, 0, None, byref(hCryptHash))
    assert_success(success)
    return hCryptHash


def CryptHashData(hHash, data):
    bdata = create_string_buffer(data)
    dwdatalen = c_int(len(data))
    success = windll.advapi32.CryptHashData(hHash, bdata, dwdatalen, 0)
    assert_success(success)


def CryptGetHashParam(hHash, dwParam):
    # determine output buffer length
    bdatalen = c_int(0)
    success = windll.advapi32.CryptGetHashParam(hHash, dwParam, 0, byref(bdatalen), 0)
    assert_success(success)

    # get hash param
    bdata = create_string_buffer(b'', bdatalen.value)
    success = windll.advapi32.CryptGetHashParam(hHash, dwParam, bdata, byref(bdatalen), 0)
    assert_success(success)
    result = bdata.raw[:bdatalen.value]
    if dwParam in [HP_ALGID, HP_HASHSIZE]:
        result = struct.unpack('I', result)[0]
    return result


def CryptDestroyHash(hCryptHash):
    success = windll.advapi32.CryptDestroyHash(hCryptHash)
    assert_success(success)


# def CryptDeriveKey(hProv, Algid, hBaseData):
#     hkey = c_void_p()
#     success = windll.advapi32.CryptDeriveKey(hProv, Algid, hBaseData, CRYPT_EXPORTABLE, byref(hkey))
#     assert_success(success)
#     return hkey

l = [ 0x33, 0x12, 0x95, 0x67, 0xE0, 0xBD, 0x78, 0x7E, 0xFB, 0x15, 0xA2, 0x63, 0x07, 0xE5, 0x31, 0x1E, 0x06, 0xBA, 0x66, 0xE3, 0xB8, 0xDB, 0xC2, 0x20, 0x6A, 0xD5, 0x9F, 0x99, 0x78, 0x0A, 0x4D, 0x78, 0xDD, 0x19, 0x16, 0x96, 0xE1, 0x5E, 0x2E, 0xE2, 0x93, 0x41, 0x0D, 0x02, 0x45, 0x4C, 0x5F, 0x94, 0x61, 0xA2, 0x24, 0x9D, 0xEE, 0x6D, 0x57, 0xC7, 0x5F, 0x26, 0x4E, 0xAE, 0xB8, 0x3A, 0x37, 0x82, 0xE7, 0x5B, 0x11, 0xDA, 0x69, 0x3D, 0x7B, 0xB5, 0x27, 0x39, 0x85, 0xDC, 0xF9, 0xF0, 0x27, 0x29, 0x45, 0x5D, 0xA7, 0xE7, 0xC8, 0x0E, 0x54, 0xA0, 0x61, 0x5E, 0x00, 0xEC, 0x2A, 0xE7, 0x6D, 0x8E, 0x04, 0x24, 0x9E, 0x0C, 0x25, 0x8E, 0x1A, 0x4E, 0x43, 0xCF, 0xDA, 0xE2, 0x91, 0xA8, 0x35, 0xCD, 0x15, 0x73, 0x5F, 0x65, 0x0B, 0xBB, 0xBA, 0x04, 0x65, 0xAD, 0xA1, 0xCD, 0x98, 0x46, 0x62, 0x2A, 0xE4, 0x22, 0x3E, 0xD2, 0x0D, 0x7E, 0xA5, 0x74, 0x0A, 0x32, 0x6E, 0x2B, 0x26, 0x8C, 0xA6, 0xDB, 0x91, 0xD0, 0x41, 0xCF, 0x51, 0x94, 0xF5, 0x77, 0xE3, 0x93, 0xA8, 0xBA, 0x3B, 0x85, 0xD8, 0xE9, 0x8B, 0x53, 0x63, 0x9F, 0x15, 0x2C, 0x8F, 0xC6, 0xEF, 0x30, 0x80, 0x2F, 0xDE, 0x46, 0x2B, 0xA0, 0xBE, 0x9C, 0xF0, 0x85, 0xF7, 0x58, 0x0D, 0xC6, 0x9E, 0xFD, 0x72, 0xE0, 0x02, 0xAB, 0xBB, 0x35, 0x01, 0x17, 0x83, 0x4B, 0xF6, 0x0D, 0xCF, 0x97, 0x72, 0x29, 0xBF, 0x1E, 0x98, 0x2C, 0xF9, 0xBC, 0x63, 0xB6, 0x0E, 0xF4, 0x20, 0x52, 0xF7, 0xCE, 0x7E, 0x80, 0x0C, 0xE1, 0x21, 0x6A, 0x9A, 0xF6, 0x74, 0x1D, 0x14, 0xDF, 0x73, 0x0E, 0x53, 0xA5, 0xA0, 0x19, 0xA7, 0x10, 0x11, 0x6F, 0x69, 0x6D, 0xB4, 0xEC, 0x23, 0xA1, 0x32, 0xB7, 0x4C, 0xF6, 0xFB, 0xB3, 0xCF, 0x76, 0x17, 0xE6, 0x83, 0x13, 0xE3, 0x0E, 0x58, 0x0A, 0x4C, 0x29, 0x16, 0xBC, 0xFF, 0x30, 0xCA, 0x04, 0x7F, 0x2D, 0x6A, 0x49, 0x41, 0x68, 0xCE, 0xAF, 0x8F, 0xB9, 0x17, 0x10, 0x37, 0xA7, 0x73, 0xA9, 0xF8, 0xE7, 0x26, 0x8E, 0x29, 0x47, 0x63, 0x75, 0x4A, 0x8E, 0xFD, 0x4C, 0x73, 0x9D, 0x9F, 0x67, 0x9B, 0xFC, 0xA3, 0xAB, 0x51, 0x01, 0x06, 0xF4, 0x2D, 0xDB, 0x5D, 0xC0, 0x21, 0x6B, 0xA8, 0xBC, 0x98, 0xBA, 0x31, 0x58, 0x46, 0xC9, 0xE2, 0x20, 0x99, 0xEE, 0x4B, 0xFE, 0x54, 0xA9, 0x9A, 0x3C, 0xDB, 0xAF, 0x69, 0xF1, 0x7F, 0x7C, 0x6E, 0x25, 0x81, 0xB9, 0x2F, 0x7B, 0xAB, 0x25, 0x12, 0x8F, 0xD2, 0x10, 0x0B, 0x7A, 0x68, 0xDB, 0xF7, 0x3D, 0x03, 0xD3, 0xA5, 0x10, 0x7E, 0xDA, 0xD3, 0xB0, 0x56, 0x76, 0xEE, 0xE2, 0x40, 0xE6, 0x8C, 0x28, 0x02, 0x96, 0xE5, 0x2B, 0x69, 0x86, 0x87, 0x3C, 0x54, 0xCE, 0xF3, 0xCB, 0xC1, 0x81, 0x8D, 0x58, 0x0D, 0x8C, 0x8B, 0xC1, 0x11, 0x30, 0x2F, 0x4A, 0x5E, 0x69, 0x03, 0xEF, 0x2D, 0x32, 0xB1, 0x1A, 0x56, 0x13, 0xEF, 0xBA, 0x50, 0x76, 0x93, 0xDE, 0x80, 0x60, 0xFB, 0x8C, 0x44, 0xAD, 0x63, 0xF6, 0x0A, 0xF0, 0xF6, 0xDB, 0x6F, 0xDD, 0xE6, 0xD5, 0x18, 0x6E, 0xF7, 0x81, 0x76, 0x36, 0x7D, 0xF2, 0x61, 0xFA, 0x06, 0xBE, 0x30, 0x79, 0xB6, 0xC8, 0x0C, 0x8A, 0xDB, 0xA4, 0x46, 0xC9, 0xE2, 0x20, 0x99, 0xEE, 0x4B, 0xFE, 0x54, 0xA9, 0x9A, 0x3C, 0xDB, 0xAF, 0x69, 0xF1, 0x7F, 0x7C, 0x6E, 0x25, 0x81, 0xB9, 0x2F, 0x7B, 0xAB, 0x25, 0x12, 0x8F, 0xD2, 0x10, 0x0B, 0x7A, 0x5E, 0x07, 0xD6, 0xFD, 0xC6, 0x02, 0xB0, 0xF9, 0xB9, 0x9F, 0x6E, 0xA2, 0x4C, 0x39, 0xE6, 0x58, 0x35, 0x99, 0x2F, 0xAA, 0xC4, 0x00, 0x26, 0x4C, 0x52, 0x44, 0x9B, 0xC4, 0x09, 0xCF, 0x4E, 0xFA, 0xE4, 0xDC, 0xD6, 0xD3, 0x13, 0xAF, 0x71, 0x55, 0x95, 0x96, 0xD3, 0x00, 0x9C, 0x12, 0xD0, 0x25, 0x30, 0x18, 0x42, 0xD8, 0xC7, 0xF8, 0x88, 0xC2, 0x85, 0x03, 0x33, 0xE9, 0x1A, 0x9B, 0xDA, 0x68, 0xFF, 0xFD, 0xFF, 0x4B, 0x07, 0xA9, 0xD9, 0x73, 0xFD, 0x1C, 0x3A, 0x6B, 0xE4, 0x43, 0x85, 0x1B, 0xC1, 0x3E, 0x82, 0xC4, 0xAF, 0x94, 0xC8, 0x83, 0x25, 0x24, 0x46, 0x94, 0xE3, 0x52, 0xAA, 0x31, 0x3F, 0xFF, 0xD0, 0x18, 0xD2, 0x22, 0x30, 0x20, 0xBE, 0x85, 0x67, 0x0D, 0x93, 0xF5, 0x65, 0xB6, 0x3D, 0xF5, 0x4A, 0x9C, 0xE3, 0xED, 0x2C, 0xDF, 0x63, 0x47, 0xA6, 0x1D, 0xF0, 0x16, 0x93, 0x8C, 0xB2, 0x94, 0x18, 0x52, 0x28, 0x25, 0x62, 0xCC, 0x3D, 0x81, 0x3E, 0x8B, 0xF1, 0x70, 0x5D, 0x04, 0x80, 0xA7, 0xA0, 0x08, 0xFF, 0xA2, 0x47, 0x55, 0x01, 0xD7, 0xC5, 0x16, 0x11, 0x65, 0xA7, 0xFB, 0x63, 0x5C, 0xA7, 0x3D, 0x00, 0xD4, 0xF2, 0x8B, 0x5F, 0x57, 0x3B, 0x16, 0xEE, 0xA5, 0x6E, 0x9E, 0x45, 0x79, 0xD7, 0x7E, 0x56, 0x1C, 0x32, 0xAA, 0x68, 0x18, 0x9D, 0x97, 0x69, 0xFA, 0x17, 0x53, 0xA4, 0xD0, 0xEF, 0x23, 0x16, 0x1B, 0x5B, 0x7C, 0x6A, 0x8D, 0x5B, 0x28, 0x75, 0x43, 0xFD, 0x74, 0xE1, 0x6B, 0x3B, 0xF3, 0x13, 0xD7, 0x1A, 0xA1, 0x87, 0xC2, 0x4C, 0xDD, 0x72, 0x8A, 0x7B, 0x1E, 0xE0, 0xB9, 0xA8, 0x79, 0x9F, 0x32, 0x45, 0x3A, 0x47, 0x8C, 0x91, 0x22, 0xF8, 0xB8, 0x3C, 0xEE, 0x68, 0xE1, 0x6D, 0xB1, 0x8F, 0x49, 0x3A, 0xC8, 0x1B, 0xC1, 0xD4, 0x74, 0x59, 0x4B, 0x5D, 0xF4, 0x56, 0x49, 0x99, 0xCB, 0xBF, 0xEA, 0x80, 0x17, 0x0B, 0xA0, 0x68, 0xDC, 0xF9, 0x61, 0xD9, 0x91, 0x46, 0x25, 0xF3, 0xBE, 0x95, 0x1B, 0x2C, 0x1F, 0xE1, 0x63, 0xBA, 0xE0, 0xF8, 0x15, 0x6C, 0x24, 0x4A, 0x44, 0xDC, 0x15, 0x36, 0x42, 0x04, 0xA8, 0x0F, 0xE8, 0x0E, 0x90, 0x39, 0x45, 0x5C, 0xC1, 0x60, 0x82, 0x81, 0x82, 0x0F, 0xE2, 0xB2, 0x4F, 0x1E, 0x52, 0x33, 0xAD, 0xE6, 0xAF, 0x1D, 0xD5, 0xE9, 0x17, 0x87, 0x06, 0x8A, 0x3C, 0x60, 0xE9, 0x71, 0x2A, 0x7A, 0xBE, 0xB6, 0xA6, 0x7F, 0x51, 0x8A, 0x40, 0x72, 0x3C, 0x1B, 0x89, 0xC1, 0x1D, 0x60, 0x70, 0xFE, 0x5F, 0x93, 0x89, 0xEB, 0xF9, 0x7E, 0xB7, 0x02, 0x57, 0x59, 0x3D, 0xA0, 0x6F, 0x68, 0x2A, 0x3D, 0xDD, 0xA5, 0x4A, 0x9D, 0x26, 0x0D, 0x4F, 0xC5, 0x14, 0xF6, 0x45, 0x23, 0x7F, 0x5C, 0xA7, 0x4B, 0x08, 0xF8, 0xDA, 0x61, 0xA6, 0x96, 0xA2, 0x96, 0xD2, 0x24, 0xF2, 0x85, 0xC6, 0x7B, 0xEE, 0x93, 0xC3, 0x0F, 0x8A, 0x30, 0x91, 0x57, 0xF0, 0xDA, 0xA3, 0x5D, 0xC5, 0xB8, 0x7E, 0x41, 0x0B, 0x78, 0x63, 0x0A, 0x09, 0xCF, 0xC7, 0x96, 0xA2, 0x96, 0xD2, 0x24, 0xF2, 0x85, 0xC6, 0x7B, 0xEE, 0x93, 0xC3, 0x0F, 0x8A, 0x30, 0x91, 0x57, 0xF0, 0xDA, 0xA3, 0x5D, 0xC5, 0xB8, 0x7E, 0x41, 0x0B, 0x78, 0x63, 0x0A, 0x09, 0xCF, 0xC7, 0x96, 0xA2, 0x96, 0xD2, 0x24, 0xF2, 0x85, 0xC6, 0x7B, 0xEE, 0x93, 0xC3, 0x0F, 0x8A, 0x30, 0x91, 0x57, 0xF0, 0xDA, 0xA3, 0x5D, 0xC5, 0xB8, 0x7E, 0x41, 0x0B, 0x78, 0x63, 0x0A, 0x09, 0xCF, 0xC7, 0x96, 0xA2, 0x96, 0xD2, 0x24, 0xF2, 0x85, 0xC6, 0x7B, 0xEE, 0x93, 0xC3, 0x0F, 0x8A, 0x30, 0x91, 0x57, 0xF0, 0xDA, 0xA3, 0x5D, 0xC5, 0xB8, 0x7E, 0x41, 0x0B, 0x78, 0x63, 0x0A, 0x09, 0xCF, 0xC7, 0x96, 0xA2, 0x96, 0xD2, 0x24, 0xF2, 0x85, 0xC6, 0x7B, 0xEE, 0x93, 0xC3, 0x0F, 0x8A, 0x30, 0x91, 0x57, 0xF0, 0xDA, 0xA3, 0x5D, 0xC5, 0xB8, 0x7E, 0x41, 0x0B, 0x78, 0x63, 0x0A, 0x09, 0xCF, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

x = 1

s = []

for i in range(32):
    xx = []
    for j in range(32):
        xx.append(l[32*i+j])
    s.append(xx)

hprov = CryptAcquireContext()

Algid = 0x0000800c


import string
import sys

w = ''
x = 0
while True:
    for i in string.printable:
        A = 0
        for j in string.printable:
            hHash = CryptCreateHash(hprov, Algid)
            CryptHashData(hHash, f'{i}{j}'.encode())

            dwParam = 2

            r = CryptGetHashParam(hHash, dwParam)

            if bytes(s[x]) == r:
                w += f'{i}{j}'
                A = 1
                x += 1
                CryptDestroyHash(hHash)
                break

            CryptDestroyHash(hHash)
        if A:
            break
    print(w)
    if '}' in w:
        break

# zer0pts{m0d1fy1ng_PE_1mp0rts_1s_4n_34sy_0bfusc4t10n}
```
